#  流量控制
#### 数据链路层控制的是相邻节点间的流量，传输层控制的是端到端的流量

#### 流控的条件：接受方的接受能力小于发送方的的发送能力

#### 使用某种机制，接收方控制发送方的数据流，是计算机网络中流量控制的基本方法

#### 两种基本方法：停等协议+滑动窗口

发送方把数据存到缓存中，然后一帧一帧的传输，接受方存到缓存中，再倒进内存

## 完全理想化的数据传输
假设一：
数据传输不会出错和丢失

假设二：
接收方完全能接受数据并及时上交

### 简单停止协议
（完全不差错传世+接收方能力不够）

```
#发送方
取出数据帧

将数据帧送到数据链路层的缓存中

将发送缓存中的数据帧发送出去

等待

收到接收方节点发送过来的信息，重复。

#接收方：
等待

收到数据帧，存在数据链路层的缓存中

把缓存中的数据上交给主机

给发送方发送信息，表示数据帧已经上交

```
```
问：简单停止协议使用的是新的帧吗？ 
简单的停止协议：如果保留假设一：每次发送的一定是新的帧
```

### 实用的停等协议
（两个假设都去掉）

```
发送方发送完一帧，就等待应答

应答为ok，继续发送

不ok，或超过规定时间没有收到应答，重新发送
-->但是不知道发送哪一个-->给帧进行编号
-->不让发送方在那里死等，就设置一个计时器
```

### 应答问题：

不适用否认帧

表示方法：ACKn-->前n-1号帧已经收到，期望收到n号帧

ACK0: 1号帧已经收到，期望收到0号帧

ACK1：0号帧已经收到，期望收到1号帧

### 发送时间
#### time_out（重发时间）：前一个帧发送完成到下一个帧开始发送的时间间隔

### 连续的ARQ协议
```
发送端：
连续发送若干个数据帧，不等确认帧，哪怕等到了确认帧，还是继续发

如果超时时间到了，还没有拿到相应帧的确认帧，就回到这个帧重新传起（go back N ARQ）

接收端：
连续接受帧，如果收到了坏帧，就丢掉这个及之后的帧，直到发送端超时重发
```
#### 发送方一刻不停的在发，接收方除非没收到都发送反馈信息，但是如果没收到，直到在收到前，新接受的数据都要丢掉

发送方每发送一个数据帧后都要设置一个超时计时器，超时了就重发

#### 特点
效率高/不实用（不考虑接收方的处理能力）/发生错误对效率的影响大。不适合出错率高的信道

## 滑动窗口协议

发送窗口对发送端进行流量控制，发送窗口W_T表示在没有收到确认帧之前最多可以发送多少个数据帧

每收到一个数据帧，窗口就向前移动一位

停止协议相当于滑动窗口的W_1

接受窗口：

接收方允许接受的帧的序号，

如果接受的数据帧超出了窗口，就不收取，只有落在这个窗口里面，才收下，并向后移位，给发送方确认信息

连续ARQ相当于W_1的窗口

```
发送窗口最大值问题？

当用n个比特对帧进行编号，若接受窗口大小为1，则发送窗口大小W_T<=2^n - 1。连续ARQ协议才能正常工作




```



























